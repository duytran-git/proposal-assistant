"""Deal Analysis document population for Google Docs."""

import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from proposal_assistant.docs.client import DocsClient

logger = logging.getLogger(__name__)

FOOTER_TEXT = "Draft generated by Proposal Assistant"


def create_versioned_document_title(title: str, version: int) -> str:
    """Create a versioned document title.

    Generates titles like "Acme - Deal Analysis v2" for regenerated documents.
    Version 1 documents omit the version suffix for cleaner naming.

    Args:
        title: Base document title (e.g., "Acme - Deal Analysis").
        version: Version number (1 = no suffix, 2+ = " v{N}" suffix).

    Returns:
        Formatted title with version suffix if version > 1.

    Examples:
        >>> create_versioned_document_title("Acme - Deal Analysis", 1)
        'Acme - Deal Analysis'
        >>> create_versioned_document_title("Acme - Deal Analysis", 2)
        'Acme - Deal Analysis v2'
    """
    if version <= 1:
        return title
    return f"{title} v{version}"


SNAPSHOT_FIELDS: list[tuple[str, str]] = [
    ("Company", "company"),
    ("Industry / Segment", "industry_segment"),
    ("Size", "size"),
    ("Contact(s)", "contacts"),
    ("Opportunity Name", "opportunity_name"),
    ("Stage & Target Close", "stage_and_target_close"),
]


@dataclass(frozen=True)
class _Segment:
    """A text segment with formatting metadata."""

    text: str
    bold: bool = False
    italic: bool = False
    heading: int = 0  # 0 = normal, 1 = HEADING_1, 2 = HEADING_2
    color: tuple[float, float, float] | None = None


def populate_deal_analysis(
    docs: "DocsClient",
    doc_id: str,
    content: dict[str, Any],
    missing_info: list[str] | None = None,
) -> None:
    """Populate a Google Doc with Deal Analysis content.

    Inserts structured content following the Deal Analysis template
    (PRD section 8) and applies formatting (headings, bold labels,
    warning colours for missing info, footer disclaimer).

    Args:
        docs: DocsClient instance for API calls.
        doc_id: Google Doc document ID.
        content: Deal analysis content dict with section keys
            (opportunity_snapshot, problem_impact, etc.).
        missing_info: Optional list of missing information labels.
    """
    segments = _build_segments(content, missing_info or [])
    requests = _segments_to_requests(segments)

    docs._docs_service.documents().batchUpdate(
        documentId=doc_id,
        body={"requests": requests},
    ).execute()

    logger.info("Populated Deal Analysis doc %s", doc_id)


# ── Segment builders ──────────────────────────────────────────────


def _build_segments(
    content: dict[str, Any],
    missing_info: list[str],
) -> list[_Segment]:
    """Build ordered text segments from deal analysis content."""
    segments: list[_Segment] = []

    # Missing info warning at top of document
    if missing_info:
        _add_missing_info_warning(segments, missing_info)

    # 1. Opportunity Snapshot
    _add_opportunity_snapshot(segments, content.get("opportunity_snapshot", {}))

    # 2. Problem & Impact
    _add_problem_impact(segments, content.get("problem_impact", {}))

    # 3. Current vs Desired State
    _add_current_desired_state(segments, content.get("current_desired_state", {}))

    # 4. Buying Dynamics & Risk
    _add_buying_dynamics(segments, content.get("buying_dynamics", {}))

    # 5. Renessai Fit & Strategy
    _add_renessai_fit(segments, content.get("renessai_fit", {}))

    # 6. Proof & Next Actions
    _add_proof_next_actions(segments, content.get("proof_next_actions", {}))

    # Footer disclaimer
    segments.append(_Segment("\n"))
    segments.append(
        _Segment(
            FOOTER_TEXT + "\n",
            italic=True,
            color=(0.6, 0.6, 0.6),
        )
    )

    return segments


def _add_missing_info_warning(
    segments: list[_Segment], missing_info: list[str]
) -> None:
    """Add missing-info warning block at the top of the document."""
    red = (0.8, 0.0, 0.0)
    segments.append(
        _Segment(
            "\u26a0 Missing Information\n",
            bold=True,
            heading=2,
            color=red,
        )
    )
    segments.append(
        _Segment(
            "The following items could not be determined "
            "from the provided materials:\n",
            color=red,
        )
    )
    for item in missing_info:
        segments.append(_Segment(f"\u2022 {item}\n", color=red))
    segments.append(_Segment("\n"))


def _add_opportunity_snapshot(
    segments: list[_Segment], snapshot: dict[str, Any]
) -> None:
    """Add Section 1: Opportunity Snapshot."""
    segments.append(_Segment("1. Opportunity Snapshot\n", heading=1))
    for label, key in SNAPSHOT_FIELDS:
        value = snapshot.get(key, "Unknown")
        segments.append(_Segment(f"{label}: ", bold=True))
        segments.append(_Segment(f"{value}\n"))
    segments.append(_Segment("\n"))


def _add_problem_impact(segments: list[_Segment], data: dict[str, Any]) -> None:
    """Add Section 2: Problem & Impact."""
    segments.append(_Segment("2. Problem & Impact\n", heading=1))
    segments.append(_Segment("2.1 Core Problem Statement\n", heading=2))
    segments.append(_Segment(f"{data.get('core_problem_statement', 'Unknown')}\n\n"))
    segments.append(_Segment("2.2 Business Impact\n", heading=2))
    segments.append(_Segment(f"{data.get('business_impact', 'Unknown')}\n\n"))


def _add_current_desired_state(segments: list[_Segment], data: dict[str, Any]) -> None:
    """Add Section 3: Current vs Desired State."""
    segments.append(_Segment("3. Current vs Desired State\n", heading=1))
    segments.append(_Segment("3.1 Current State\n", heading=2))
    segments.append(_Segment(f"{data.get('current_state', 'Unknown')}\n\n"))
    segments.append(_Segment("3.2 Desired Future State\n", heading=2))
    segments.append(_Segment(f"{data.get('desired_future_state', 'Unknown')}\n\n"))


def _add_buying_dynamics(segments: list[_Segment], data: dict[str, Any]) -> None:
    """Add Section 4: Buying Dynamics & Risk."""
    segments.append(_Segment("4. Buying Dynamics & Risk\n", heading=1))
    segments.append(_Segment("4.1 Stakeholders & Power Map\n", heading=2))
    segments.append(_Segment(f"{data.get('stakeholders_power_map', 'Unknown')}\n\n"))
    segments.append(_Segment("4.2 Decision Process & Timing\n", heading=2))
    segments.append(_Segment(f"{data.get('decision_process_timing', 'Unknown')}\n\n"))
    segments.append(_Segment("4.3 Perceived Risks\n", heading=2))
    segments.append(_Segment(f"{data.get('perceived_risks', 'Unknown')}\n\n"))


def _add_renessai_fit(segments: list[_Segment], data: dict[str, Any]) -> None:
    """Add Section 5: Renessai Fit & Strategy."""
    segments.append(_Segment("5. Renessai Fit & Strategy\n", heading=1))
    segments.append(_Segment("5.1 How Renessai Solves Top Pains\n", heading=2))
    segments.append(
        _Segment(f"{data.get('how_renessai_solves_top_pains', 'Unknown')}\n\n")
    )
    segments.append(
        _Segment(
            "5.2 Differentiation vs Status Quo / Competitors\n",
            heading=2,
        )
    )
    segments.append(
        _Segment(f"{data.get('differentiation_vs_status_quo', 'Unknown')}\n\n")
    )
    segments.append(_Segment("5.3 Delivery & Phasing Idea\n", heading=2))
    segments.append(_Segment(f"{data.get('delivery_phasing_idea', 'Unknown')}\n\n"))


def _add_proof_next_actions(segments: list[_Segment], data: dict[str, Any]) -> None:
    """Add Section 6: Proof & Next Actions."""
    segments.append(_Segment("6. Proof & Next Actions\n", heading=1))
    segments.append(_Segment("6.1 Proof Points to Use\n", heading=2))
    segments.append(_Segment(f"{data.get('proof_points_to_use', 'Unknown')}\n\n"))
    segments.append(_Segment("6.2 Next Steps\n", heading=2))
    segments.append(_Segment(f"{data.get('next_steps', 'Unknown')}\n\n"))


# ── Request builder ───────────────────────────────────────────────


def _segments_to_requests(
    segments: list[_Segment],
) -> list[dict[str, Any]]:
    """Convert text segments to Google Docs API batchUpdate requests.

    Inserts all text at index 1, then applies paragraph and text
    style formatting based on each segment's metadata.

    Args:
        segments: Ordered list of text segments with formatting.

    Returns:
        List of Google Docs API request dicts.
    """
    full_text = "".join(s.text for s in segments)
    if not full_text:
        return []

    requests: list[dict[str, Any]] = [
        {
            "insertText": {
                "location": {"index": 1},
                "text": full_text,
            }
        }
    ]

    offset = 1
    for segment in segments:
        end = offset + len(segment.text)

        # Paragraph style (headings)
        if segment.heading:
            requests.append(
                {
                    "updateParagraphStyle": {
                        "range": {
                            "startIndex": offset,
                            "endIndex": end,
                        },
                        "paragraphStyle": {
                            "namedStyleType": f"HEADING_{segment.heading}",
                        },
                        "fields": "namedStyleType",
                    }
                }
            )

        # Text style (bold, italic, colour)
        style_fields: list[str] = []
        text_style: dict[str, Any] = {}

        if segment.bold:
            text_style["bold"] = True
            style_fields.append("bold")

        if segment.italic:
            text_style["italic"] = True
            style_fields.append("italic")

        if segment.color:
            r, g, b = segment.color
            text_style["foregroundColor"] = {
                "color": {"rgbColor": {"red": r, "green": g, "blue": b}}
            }
            style_fields.append("foregroundColor")

        if style_fields:
            requests.append(
                {
                    "updateTextStyle": {
                        "range": {
                            "startIndex": offset,
                            "endIndex": end,
                        },
                        "textStyle": text_style,
                        "fields": ",".join(style_fields),
                    }
                }
            )

        offset = end

    return requests
